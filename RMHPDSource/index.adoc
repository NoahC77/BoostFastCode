= Developing DevDocs
~csim
Version 0.0, 05.04.2020
:sectnums:
:toc:
:toclevels: 4
:toc-title: Table of Contents
:description: Developing DevDocs
:keywords: AsciiDoc
:imagesdir: ./img
:source-highlighter: highlight.js


== Getting Started

To contribute or get the latest version:

=== Setup your gitlab ssh key pair

Generate an ssh keypair for use with gitlab using one of the options below.

include::ssh-keygen.adoc[indent=4]

Next, add your ssh public key to gitlab. By default the ssh public key
will reside in your `~/.ssh` directory and have a `.pub` extension.

You can find instructions for adding your ssh key to your account at the
URL below:

IMPORTANT: Be sure to replace any instance of gitlab.com with
           gitlab.circ.utdallas.edu.

https://gitlab.circ.utdallas.edu/help/ssh/README.md#adding-an-ssh-key-to-your-gitlab-account

=== Set up your local environment

The following gives you steps to take to setup your local environment so
you can visualize changes before committing them to the upstream
repository.

We will be making use of containers to build a local copy of the site. With
containers, you will be able to make local edits and see what the site will
look like on your machine. The containers that have been tested and are
known to work are https://www.docker.com/[Docker] and
https://podman.io/[Podman].

For editing a single file where you want to see real-time updates, you
can install the asciidoctor Live Preview plugins below.

* Install git (outside the scope of this document)
* Fork the devdocs git repository from gitlab:
** Navigate to the
   https://gitlab.circ.utdallas.edu/circ/documentation/devdocs[devdocs
   git repository] and click on *Fork*
+
image::gitlab-fork-repository.png[]
+
** Under *Select a namespace to fork the project*, click on your name
* Clone your forked devdocs git repository from gitlab

    git clone git@gitlab.circ.utdallas.edu:<your username>/devdocs.git
+
[IMPORTANT]
====
`<your username>` will need to be replaced with your gitlab username
(most likely your netid)

====
+
* Install Docker or Podman (outside the scope of this document)
+
NOTE: Podman is the preferred container tool if you are running on
      RHEL/CentOS/Fedora (or any derivative distribution)
* Build a local copy of the site from the sources
** Change to the devdocs directory and run one of the following:
+
*docker*

    docker run -u $(id -u) -v $PWD:/antora --rm -t antora/antora site.yml
+
*podman*

    podman run -v $PWD:/antora:Z --rm -t antora/antora site.yml
+
** You can now browse the site locally by opening a browser tab and
   navigating to:

    <git clone directory>/build/site/devdocs/index.html
+
* Download a web browser asciidoctor plugin for Live Previews:
** https://chrome.google.com/webstore/detail/asciidoctorjs-live-previe/iaalpfgpbocpdfblpnhhgllgbdbchmia?hl=en[Chrome Asciidoctor.js Live Preview]
** https://addons.mozilla.org/en-US/firefox/addon/asciidoctorjs-live-preview/[Firefox Asciidoctor.js Live Preview]
* Web Browser > Open File > Browser to this document "<clone location>"
  > file.adoc
* Saved changes to the file will cause it to re-render in your web browser

==== Documentation git workflow

The following describes the workflow that we will try to use for modifying
documentation. This assumes you have already cloned the git repository per
the instructions above.

* Create a local branch for your change. For example, let's say we're
  working on a change that fixes *foo*. While branch names are arbitrary, it
  might make sense to create a branch named *fix-foo*.

    git checkout -b fix-foo
+
* Make changes as necessary to fix *foo*.
* Verify your changes.

    git diff
+
* Once you are happy with your changes, commit them to your local *fix-foo*
  git branch.

    git commit -asv
+
* Push your changes to your gitlab devdocs fork

    git push --set-upstream origin
+
* Create a merge request to have someone review your changes and get
  them merged upstream

Once you have completed the steps above, your branch can either be thrown
away or reused for something else.

=== Goals

While the primary goal of this project is to design the tools and
infrastructure, a secondary goal is to develop the best practices
for nontechnical PI and technical student collaboration. Not all PIs
are going to learn Git, Gitlab, Asciidoctor, CI/CD, etc., etc., etc.
However, hopefully we can get PIs to edit a text file. Even though that
text file might be an asciidoc source, it is human readable and with
the smallest training, PIs can contribute.

TIP: Chris is not going to contribute on the backend at all (at least
     initially).

We want to try for all of us to work together using this git repository.
Email should be used as little as possible.  As part of this process,
I want to also develop and document how to interact between these
two worlds.  For the purposes of this exercise, Chris is non-technical.

NOTE: Longer term, this will be disseminated via papers and
      conferences. Anyone is welcome to contribute at that level.

[WARNING]
====
Your first task is to follow the directions above and set yourself up
to contribute to this document.  At the end of this document is a team
member list.  Your second task is to find your name, add your email,
and strikethrough yourself on the list below.

====

.Team members who are not ready to collaborate:
* [line-through]#Dr. Christopher S. Simmons#
* [line-through]#Sol Jerome#
* [line-through]#Noah Castetter#
* [line-through]#Sasmita Mohapatra#
* [line-through]#Micaela Chan#
* [line-through]#Georgia Stuart#


== DevOps
<<devdocs.adoc#,Return to TOC>>

https://en.wikipedia.org/wiki/DevOps[DevOps] as defined by wikipedia
is a set of practices that combines software development (Dev) and
information-technology operations (Ops) which aims to shorten the systems
development life cycle and provide continuous delivery with high software
quality.

Basically, by treating our operations work as a software development
project, we will be able to manage orders of magnitude more resources
with less work.

Our DevOps framework uses the following Base Technologies:

* https://git-scm.com/[Git] / https://gitlab.com/[GitLab]
* https://bestpractical.com/request-tracker[Request Tracker]
* https://www.ansible.com/[Ansible]
* https://netbox.readthedocs.io[Netbox]
* Teams
* Webhooks
* Email

The short term goal is to deprecate the previous stop gap implementation
run on oithpc.utdallas.edu including redmine, ganymedeadmins, opendcim,
and sphinx.

Base Technologies getting replaced:

* No version control -> Git
* Redmine -> Gitlab
* Email List ganymedeadmins -> circ-assist@utdallas.edu
* Opendcim -> Netbox
* Sphinx -> Asciidocs
* On-premises oithpc.utdallas.edu -> AWS VM + KVM

== DevDocs
<<devdocs.adoc#,Return to TOC>>

[NOTE]
====
DevDocs is taking the similar philosophy of DevOps and applying it to
documentation.  That is, we are going to treat our documentation as a
software project and enable CI/CD of documentation.

====
While the most pressing need is sysadmin docs, this framework will also
be used as a platform to deliver educational content as well as be used
passively (to document) and actively (to drive) research.  It can be
used to develop simulation campaign status reporting with Wiki-based or
HTML5 output and can lower the barrier of entry for faculty without CI
skills to collaborate with their students.  Finally, research with and
connections to the reproducibility communities will be made.

=== Workflow
<<devdocs.adoc#,Return to TOC>>

* Asciidoc will be used for the markup language
** Asciidoctor will be used as the toolchain to process Asciidoc sources
** It can be Makefile driven for local builds for testing
** Chrome and Firefox plugins provide WYSIWYG real time markup rendering
* Two options for the backend Git repo
** Gitlab Pages Repo
*** Can use a Makefile to generate the HTML and be done with it
*** Alternatively, you can use a static site generator to call asciidoctor
    opening up new features
*** Gatsby.js and Hugo will be explored
** Gitlab Wiki repo
*** Asciidoc can be used in place of Markdown to replace Gitlab default
    wiki format
*** Technical users can use git + text editor
*** Non-technical users can edit directly using the Gitlab Wiki's
    built-in editor
* Asciidoc sources will be commited to Git hosted on Gitlab at AWS
* Gitlab’s CI/CD system will be used to build doc sources on checkin
* Built sites can be delivered as:
** Gitlab Pages website
** Gitlab wiki page
** Static sites served via any web server
** Packaged as applications via electronjs with branded Icons

=== Lowering the Barrier of Entry
<<devdocs.adoc#,Return to TOC>>

NOTE: https://www.sparkleshare.org/[Sparkleshare] will be used like Box
      for Git


Another great integration point is to use sparkleshare with the gitlab
asciidoc repo to provide always up to date, automatically syncing of
Asciidoc documentation. Non-technical users can simply edit a .adoc source
file in a local laptop/desktop 'cloud store' provided by sparkleshare.
When saved, it’ll automatically be sent to gitlab and the build chain
can be initiated.  The main disadvantage is the loss of the metadata
associated with the git commit.  We get the time of the commit and the
user but all we get is a "sparkleshare commited this" message.

.Other thoughts
* Additional integrations can be done to distribute documentation to
  Box shares via the box cli tools
** Box shares can be used to bootstrap efforts
** Set up DevDocs project; Distribute via boxcli
** Boxcli also sends invitation to collaboration / PI
** In the Box share is the html5 and also intstructions on how to set
   up all OSs to contribute
* Longer term, we aim to develop branded https://www.electronjs.org Apps
** Same concept can easily be used to build "project" web apps
** A PI can be given a "web browser" via electron and all the web browser
   does is display DevDocs pages
** This web browser can be distributed via Box
** Longer term, devs will be able to create their own "application"
   that they can distribute to the public
** Users will be able to develop "show case" research websites driven
   by their own personal app
** Scientists will be able to carry a personal electron app and use that
   to give talks and present their research
** All a scientist ever needs is a web browser
* Asciidoctor sources can also be use to generate latex and man pages
* Teams integration
* Explored as a research communication platform
* Explored as a reproducibility tool
* Explored as an educational platform to deliver self taught education
* Slide decks can be prepared from the same asciidoctor markup using
  react.js

https://revealjs.com/#/[Reveal.js] allows the generation of slide
decks with two navigatable dimensions (supports left right and up down
navigation).  This facilitates compelling reference documentation /
Quickstart where the user controls the level of detail along the y axis
while the subject matter is controlled along the x axis.  All of this
is html5 and is responsive.  Works very well on all platforms including
mobile.

NOTE: New forms of pedagogy will be explored for communication of science
      as well as teaching computational science

=== Notional Time line

.Phase 0 - Humans write documentation
* base capability as above
* human checks in asciidoc sources to git:
** via git cli or git gui
** via sparkleshare / cloud sync
* human checkins trigger builds
* results presented via a variety of methods

.Phase 1 - Computers (Workloads/flows) start triggering builds to generate documentation
* enable workloads to trigger commits:
** slurm script
** jupyter notebook
** others?
* workloads commit:
** input file
** results
** simulation status
** metadata about run
** performance metrics?
** others?
* workloads trigger builds

.Phase 2 -- Everything gits done

Humans (Documentation) trigger Computers (Workloads/flows) which trigger
builds to generate documentation

[NOTE]
====
The final phase is to document everything first. Results are automatically
generated from documentation. This is notional for now and will require
a research effort to enable.

====

== The Team

* Dr. Christopher S. Simmons -- simmons@utdallas.edu; Non-technical user
* Sol Jerome -- solj@utdallas.edu; OIT CI Staff; backend dev
* Noah Castetter -- nbc170001@utdallas.edu; OIT CI Student; frontend dev
* Sasmita Mohapatra -- sasmita@utdallas.edu; OIT CI Staff; research
  facilitation / support documentation
* Micaela Chan -- mchan@utdallas.edu; RA CVL; research documentation
  use case 1
* Georgia Stuart -- georgia.stuart@utdallas.edu; ABD NSM; research
  documentation use case 2

== The List

First thing we need to do is get this into git and set up a gitlab
project.

* [x] everyone log into https://gitlab.circ.utdallas.edu/
* [x] set up devdocs project on gitlab
* [x] invite everyone
* [x] create a wiki page as an asciidoc document
* [x] add this document as the wiki page
* [ ] document adding ssh key and checking out the git repo
* [ ] replace the 'getting started' section above with git/gitlab
      instructions instead of Box

Three different ways to deploy asciidoc + gitlab

* wiki as per above
* makefile driven via CI/CD or alternative build system
* CI/CD calls a static site generator such as
  https://www.gatsbyjs.org/[Gatsby] or https://gohugo.ioa[Hugo]

The wiki way I see as a great way to start collaborating with
non-technical / technical colleagues afraid of code. It might be a good
way to get our OIT colleagues to start using it without first having to
learn git. Once this doc is a wiki, all of us should play with it via
git as well as in the web browser via edit wiki. We need to understand
if the web markup works well for this format.

The makefile driven way will be the perfect platform to start the
science documentation work. It provides a way to generate plots / post
process data at document checkin time. Instead of plotting the data,
saving the plot, and inserting it into the documentation as a binary, we
check in the data to git and the scripts to generate the binary "result"
and rebuild every check in. This guarantees it is reproucible and you've
captured the necessary info to document the process.

The makefile driven way can then be presented as standalone websites
that we could run on any domain via any web server. However, initially we
will focus on using https://docs.gitlab.com/ee/user/project/pages/[Gitlab
Pages] as the delivery mechanism.

NOTE: Do we need a Makefile training for this group? I have a class
      lecture on it I could give.

Finally, the static site generator is how we will build end user content
to deliver a web site for documentation and training. It will allow us
to develop and deploy rich websites to meet a diverse set of needs.

The first product I want to come out of this is a PDF (written in asciidoc
and saved in git/gitlab) that can be sent to a new user to help get them
up and running. It will contain:

IMPORTANT: Do we want to set up a MS Team for this work?




== Acronym Reference
<<devdocs.adoc#,Return to TOC>>

== Revision History
<<devdocs.adoc#,Return to TOC>>

[cols="1,6a,2,2", options="header"]
|===
|Version|Changes|Author|Date


4+^h|*Release TBD*


|0.0
|Initial version
| ~csim
| May 4 2020
|===
// vim: set syntax=asciidoc:
